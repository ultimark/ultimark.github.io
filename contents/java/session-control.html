<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link rel="stylesheet" href="../../css/style.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<title>セッションの利用</title>
</head>
<body class="blue-grey darken-4 grey-text text-lighten-5">
	<div class="layout-container">
		<div class="navbar-fixed">
			<nav class="grey darken-4">
				<div class="nav-wrapper">
					<div class="container">
						<a href="index.html" class="brand-logo">Ultimark</a>
					</div>
				</div>
			</nav>
		</div>
		<div class="container layout-content">
			<h4 class="layout-title">セッションの利用</h4>
			<section class="section z-depth-2">
				<h5 class="section-title">１．セッションの必要性</h5>
				<p>Webアプリケーションにおけるセッションとは複数のリクエストにまたがって情報を保持する仕組みのことです。WebクライアントとWebサーバーのみの構成だった場合、<!--
				-->リクエストの生存期間がそれほど問題になることはありません。以下の図のようにWebクライアントからWebサーバーへの一度の要求がそのままリクエストの生存期間に<!--
				-->なるからです。</p>
				<img src="../../img/WS000079.JPG" class="responsive-img z-depth-2"/>
				<p>しかし、Webクライアントから送信されたリクエストがレスポンスとしてWebクライアントに返却されるまでにアプリケーションサーバーが介在すると、途端にリクエストの<!--
				-->生存期間が見えづらくなります。それはWebサーバーからアプリケーションサーバーへリクエストが転送され、さらには<!--
				--><a href="servlet-screen-nav.html" target="_blank">前回の記事</a>で説明したようにフォワードやインクルードといった仕組みを使ってアプリケーション<!--
				-->サーバー内でもリクエストの転送が行われるからです。しかし、難しく考える必要はありません。アプリケーションサーバー内でどれだけ複雑な仕組みになっていようとも、<!--
				-->Webクライアントにレスポンスが返された時には既にリクエストの情報は失われていることに変わりありません。</p>
				<p>ここで問題となるのが、Webクライアントにレスポンスが返された後も情報を保持し続けたい場合です。例えばユーザーのログイン情報は一度のリクエストで消失して<!--
				-->しまうとリクエストを送信するたびにユーザーIDやパスワードを入力しなければならなくなりますし、ネット通販におけるショッピングカートの中身がリクエストにたびにクリア<!--
				-->されてしまってはショッピングカートという機能そのものが成立しません。そこで複数のリクエストにまたがって情報を保持する仕組みであるセッションという概念が誕生<!--
				-->しました。</p>
				
				<h5 class="section-title">２．サーブレットにおけるセッションの実装</h5>
				<p>セッションは一般的には<a href="https://ja.wikipedia.org/wiki/HTTP_cookie" target="_blank">Cookie</a>にセッションIDと呼ばれる<!--
				-->セッションを一意に特定するための値を保持することによって実現しています。セッションIDに紐付く情報はアプリケーションサーバー側で保持しています。Cookieは<!--
				-->Webブラウザ側で保存されますので、サーバー側でセッションが生存し続ける限り何度でもセッションにアクセスすることが可能となっています。サーブレットにおいては<!--
				-->HttpSessionオブジェクトによって実装され、プログラマーはCookieの操作などを特に意識することなく利用できるようになっています。それではセッションを使った<!--
				-->サーブレットのサンプルを見てみましょう。</p>
				<img src="../../img/WS000080.JPG" class="responsive-img z-depth-2"/>
				<p>今回は複数のリクエストにまたがってセッションが生存していることを確かめるためにJSPを2つ用意しました。単純に1つ目のJSPからリンクをクリックすることで2つ目の<!--
				-->JSPに遷移するという構成です。それぞれでリクエストに保存されたメッセージとセッションに保存されたメッセージの両方を表示させようとしています。</p>
				<img src="../../img/WS000081.JPG" class="responsive-img z-depth-2"/>
				<img src="../../img/WS000082.JPG" class="responsive-img z-depth-2"/>
				<p>実際に実行してみましょう。</p>
				<img src="../../img/WS000083.JPG" class="responsive-img z-depth-2"/>
				<p>1つ目のJSPが表示されました。リクエストに保存されたメッセージもセッションに保存されたメッセージも両方正しく表示されています。リンクをクリックして2つ目のJSP<!--
				-->に遷移してみます。</p>
				<img src="../../img/WS000084.JPG" class="responsive-img z-depth-2"/>
				<p>今度はリクエストに保存されたメッセージの表示がnullとなりました。これはリンクをクリックしたときに発出されたリクエストが1つ目のJSPを表示した際のリクエストとは<!--
				-->まったく別物になっていることを意味します。一方でセッションに保存されたメッセージはリクエストが新しく生成されても正しく表示されています。複数のリクエストにまたがって<!--
				-->セッションに保存した情報が生存していることが確認できたと思います。</p>
				
				<h5 class="section-title">３．セッション利用の問題点</h5>
				<p>セッションが複数のリクエストにまたがって生存し続けることをサンプルを通して見てきました。応用すればユーザーのログイン情報やショッピングカートなど様々な機能に<!--
				-->利用できるとても便利で強力な機能なのですが、リクエストと比べて生存期間が長いことが問題になります。即ち、どこからどこまでを1回のセッションとするかという問題です。<!--
				-->例えばログインを要するようなシステムではユーザーがログインしてからログアウトするまでを1回のセッションとするのが適切でしょう。しかし、ユーザーがこちらの注文どおりに<!--
				-->ログアウトの操作をしてくれるとは限りませんし、用が済めばブラウザを閉じてしまうかもしれません。このような場合にいつまでセッションを保持し続けるのかということが<!--
				-->問題になります。この為、多くのサーバーソフトウェアでは最後にリクエストが送信されてから一定時間経過するとセッションを破棄する仕組み（セッションタイムアウト）が<!--
				-->実装されています。</p>
				<p>また、リクエストに比べて長期間データを保持することができるため、使い終わったらクリアしておかないとシステムが不正な動作を起こす原因にもなりかねません。<!--
				-->例えば購入手続きが終わった商品がショッピングカートに残り続けたら大きな問題になりかねないことは容易に想像がつくと思います。新たなリクエストが作られる頃には<!--
				-->プログラマーが特に意識しなくても勝手に情報が消えてくれるリクエストとは違って、セッションからデータをクリアするためにはプログラマーが明示的にクリアするための処理を<!--
				-->記述する必要があるという点は常に意識しておくべきです。</p>
				
				<h5 class="section-title">４．セッションのクリア</h5>
				<p>前節で述べたように、セッションは強力な機能である反面プログラマーによる管理が必須です。ここでは、不要となった情報の削除・セッションそのものの破棄といった<!--
				-->セッション管理の実装について見ていきます。先ほど作成したサーブレットを以下のように修正します。</p>
				<img src="../../img/WS000085.JPG" class="responsive-img z-depth-2"/>
				<p>25行目のsession.invalidateメソッドがセッションを破棄するメソッドになります。遷移先のJSPは以下のように修正します。</p>
				<img src="../../img/WS000086.JPG" class="responsive-img z-depth-2"/>
				<p>これを実行すると以下のようなエラーになります。</p>
				<img src="../../img/WS000087.JPG" class="responsive-img z-depth-2"/>
				<p>明示的にセッションを破棄するのはシステムからログアウトする時がほとんどだと思いますが、覚えておくと良いと思います。実用上はセッションそのものを破棄するのではなく<!--
				-->セッションに保存したデータをクリアする方が利用頻度が高くなると思います。この場合はHttpSessionオブジェクトのremoveAttributeメソッドを利用します。勘の良い<!--
				-->人は既に気付いたと思いますが、このメソッドはsession.setAttributeメソッドで保存したデータを消去する役割を担います。またまたサーブレットを修正します。</p>
				<img src="../../img/WS000088.JPG" class="responsive-img z-depth-2"/>
				<p>JSPも以下のように修正します。</p>
				<img src="../../img/WS000089.JPG" class="responsive-img z-depth-2"/>
				<p>JSPの10行目でsession.removeAttributeメソッドを呼び出し、"sessionMessage"という名前で保存されているデータを消去しています。実際に実行結果を<!--
				-->確認してみましょう。</p>
				<img src="../../img/WS000090.JPG" class="responsive-img z-depth-2"/>
				<p>セッションに保存されたデータはJSPが読み込まれた際にクリアされていますので、サーブレット側で設定した"セッションクリアのサンプル"という文字列ではなくnullが表示<!--
				-->されました。セッションは非常に便利な仕組みなのですが、管理が煩雑になるので濫用は避けるべきです。セッションを使う場合はセッションそのものを破棄する方法、<!--
				-->セッションに保存されたデータを消去する方法をしっかりと理解したうえで活用してください。</p>
				
				<div class="section-return">
					<a href="../../index.html" class="btn waves-effect waves-light">トップ</a>
				</div>
			</section>
		</div>
	</div>
</body>
</html>